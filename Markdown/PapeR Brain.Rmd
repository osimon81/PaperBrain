---
title: "PapeR Brain"
author: "Simon Ogundare"
date: "1/2/2022"
output:
  html_document:
    toc: TRUE
    toc_float: TRUE
    number_sections: TRUE
    theme: "darkly"
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

Hey there! This is an R Markdown document showcasing one particular use of the `networkd3` package. Here, we use the `simpleNetwork()` package to plot Micro-Networks, used to model biological neural networks in terms of computational functions.

## The neuron

The graphs you'll see here are a digital iteration of a project I started in 2021, aptly called "Paper Brain." I set up basic neuron models on paper which consists of only two actions: 

- A neuron will fire an excitatory pulse when triggered
- A neuron will fire an inhibitory pulse when triggered

Pulses (action potentials) are additive — so, if a neuron A receives 2 inhibitory pulses and 3 excitatory pulses from presynaptic neurons, neuron A will fire. If the same neuron receives 3 excitatory pulses and 3 inhibitory pulses, neuron A will not fire.

Evidently, this is an oversimplification for neuronal activity (no clear exploration of how networks change over time, neuromodulation, or all that jazz). However, it can be a pretty nifty tool to learn how to explore the grey areas between what we call "neural networks" in a computational perspective, and a biological one.

## Decision-making

To begin, I started by exploring how we make decisions. In the context of code, we love to rely on certain models to give our programs functionality. In effect, the code we use, when we use `if`, `ifelse`, or `else` statements, gives our programs autonomous "decision-making" capacity (if only in any basic sense).

### Fight OR Flight

The stress response — the triggered release of stress hormones to respond to a potentially threatened environment — can be triggered by both external and internal changes in an environment or cognition, respectively. However, for simplicity, let's consider some environmental factors that might contribute to such a response:

- Sensory: Feeling a sense of pain in response to an environmental change
- Visual: Sighting a predator or dangerous object in one's immediate vision
- Auditory: Hearing a sound associated with a particular conditioned fear

These are all factors that could contribute to the release of stress hormones, in any combination. Either a sensory, visual, or auditory stimulus could result in this response (or even all three at the same time).

In code, we could use OR (| operator), AND (& operator), or even NOT (! operator) to assess these sensory inputs. My model does not account for what we'd refer to as "weights" in an artificial neural network sense (yet), which considers how important a sensory input is in determining the overall result following the circuit. However, using the previously-mentioned model for neurons, we can actually model what these functions may look like in a biological sense.

### Motive

When we put together the structures for decision-making operators, these may be the structural motifs we may want to search for when we consider the expanse of the neural circuits in the human brain.

While this depiction may not currently be completely generalizable to a brain in its complexity, analyzing the simplest model may present us with an easier model we can use to dissect the true circuits.

# Paper Brain

## On paper

Something something something diagram something something something insert paper brain image

## On the screen

### Loading `networkd3`

We'll start by loading `networkD3`, once this package is installed. We'll use the `simpleNetwork()` function to plot our functional motifs for conditional operators:

```{r}
library(networkD3)
```


### The And MicroNetwork

The structure of the `simpleNetwork()` function is designed to generate a [force-directed network](https://en.wikipedia.org/wiki/Force-directed_graph_drawing). The syntax is based on a vector of sources (the nodes or neurons which project out to other neurons), and targets (the nodes or neurons which the sources project to). In the `simpleNetwork()` function, the indices for a certain source and target are paired, such that in the generated diagram, a connection exists between the source neuron and the target neuron.

In the code below, two character vectors are added to the global environment in order to generate a force-directed diagram. The nomenclature for each neuron in the vectors is as follows:

- Neurons with a + or - at the end of their name will either generate an excitatory or inhibitory impulse once they are triggered. For instance, (1a)+ is excitatory, and (6a)- is inhibitory.
- Neurons with a capital letter (A, B, or C) outside of parentheses are either input neurons or output neurons. Neuron Aa (In) is an input neuron, and neuron Da (Out) is an output neuron. Assume all input and output neurons are excitatory.
- The lowercase letter in front of the capital letter (for In/Out neurons) or numbers (for +/- interneurons) are unique letter identifiers corresponding to which motif these neurons are a part of. In this case, all of these neurons are labeled with an "a," which indicate that these are all part of the AND MicroNetwork.

In the context of this syntax, we can understand that input neuron Aa (In), located in the srcAND vector, is connected to excitatory interneuron (1a)+, located in the targetAND vector.

The nomenclature system may appear overly complicated at a glance, but this system ensures that every neuron in a MicroNetwork (or combination of MicroNetworks) can be isolated and identified. I'm also open to suggestions as to how the nomenclature for these neuron models can be improved, so feel free to reach out!

While visualization of this network solely based on these two vectors can be relatively complex, we can use this information to plot our visualization using `simpleNetwork()`.

```{r, echo = TRUE}
srcAND <- c("Aa (In)", "Ba (In)", "Ca (In)",
            "(1a)+", "(2a)+", "(3a)+",
            "(1a)+", "(2a)+", "(3a)+",
            "(4a)+", "(4a)+", "(6a)-",
            "(7a)-", "(5a)+")
targetAND <- c("(1a)+", "(2a)+", "(3a)+",
               "(4a)+", "(4a)+", "(4a)+",
               "(5a)+", "(5a)+", "(5a)+",
               "(6a)-", "(7a)-", "(5a)+",
               "(5a)+", "Da (Out)")

andNetwork <- data.frame(srcAND, targetAND)

head(andNetwork)

```

Using `head(andNetwork)` shows the first 6 rows of the data frame we constructed, where we pair the source and target vectors. This is a better way to inspect connectivity, and this is the data we will feed into the `simpleNetwork()` function.


The function below plots our And MicroNetwork. The graph is interactive, and nodes can be dragged around to better visualize the network. You can mouse-hover over neurons to reveal the neurons they're connected to. I recommend dragging the input neurons to one side and outputs to the other side, in order to see the connections between neurons better.

```{r}
micronetAND <- function() {
  simpleNetwork(andNetwork, fontSize = 14,
                linkDistance = 100, zoom = FALSE)
}


micronetAND()
```

### The Loop MicroNetwork

We can achieve the same goals with the Loop MicroNetwork. Here, we initialize our (much smaller) network of neurons involved in the loop. Assess how each neuron connects with one another using these two vectors, or using the paired data frame:

```{r}
srcLOOP <- c("Al (In)",
             "(1l)+", "(2l)+", "(3l)+", "(4l)+",
             "(3l)+")

targetLOOP <- c("(1l)+",
                "(2l)+", "(3l)+", "(4l)+", "(1l)+",
                "Bl (Out)")

loopNetwork <- data.frame(srcLOOP, targetLOOP)

head(loopNetwork)
```

Here, we plot the loop MicroNetwork. Inspecting the network, the network appears to be a positive feedback loop, where an incoming excitatory sensory neuron triggers this loop. Every time neurons fire from 1 -> 2 -> 3 -> 4 -> 1, an output neuron Bl (Out) is fired.

```{r}
micronetLoop <- function() {
  simpleNetwork(loopNetwork, fontSize = 14, nodeColour = "green",
                linkDistance = 100, zoom = FALSE)
}

micronetLoop() # generate our network!
```


### A Loop Variation

The code below constructs a data frame with two extra connections added to both srcLOOPv1 and targetLOOPv1. These extra connections can be seen at the bottom 2 rows of the outputted data frame.

Try to use the nomenclature system to figure out how this modifies the Loop MicroNetwork

```{r}
srcLOOPv1 <- c("Al (In)",
             "(1l)+", "(2l)+", "(3l)+", "(4l)+",
             "(3l)+", "(2l)+", "(5l)-")

targetLOOPv1 <- c("(1l)+",
                "(2l)+", "(3l)+", "(4l)+", "(1l)+",
                "Bl (Out)", "(5l)-", "(4l)+")

# construct data frame with source and target vectors

loopNetworkv1 <- data.frame(srcLOOPv1, targetLOOPv1)

loopNetworkv1 # display our data frame!
```

Notice the two extra rows of connections added in this variation of the Loop MicroNetwork, and how this changes the structure (and therefore functionality) of the overall Loop:

```{r}
micronetLoopv1 <- function() {
  simpleNetwork(loopNetworkv1, fontSize = 14, nodeColour = "violet",
                linkDistance = 100, zoom = FALSE)
}

micronetLoopv1() # generate our network!
```

Inhibitory interneuron 5 was formed to bridge excitatory neurons 2 and 4 in the loop, which allows the loop to run for exactly one time before terminating the loop. This variation takes synchronization of latency into account (i.e. the excitatory signal from 2 -> 3 -> 4 will reach interneuron 4 at the same time 2 -> 5 -> 4 reaches this interneuron because the same number of neurons are fired and the same number of synapses are crossed).

This MicroNetwork could be seen in a setup with sensory neuron which fires only once, and requires the signal to be terminated once this signal is directed to the output of the loop. Without the inhibitory element of interneuron 5, the loop would operate indefinitely. Signifying this structure in code, it could be represented as:

`for (i in 1:1) {`
  `triggerOutput()`
`}`

Clearly, many variations can be made using this underlying structure, and exploring factors such as signal latency (which was utilized to generate loop v1) gives this model a degree of flexibility and adaptability for predicting and modeling various neural systems in the brain using basic structures.

## Combining MicroNetworks

### Isolated MicroNetworks

As mentioned, every neuron which is part of a distinct MicroNetwork has a unique identifier. As a result, multiple networks can be stitched together and viewed as a singular, poly-network assembly. In the following code, we put the "And" and "Loop" networks in the same environment (not neurally connected, however). This is in order to allow you to manipulate both MicroNetworks and visualize the multiplicity of ways that they can be connected to one another.

```{r}
micronetAndLoop <- function() {
  srcBOTH <- c(srcAND, srcLOOP)
  targetBOTH <- c(targetAND, targetLOOP)
  
  dualComponentNetwork <- data.frame(srcBOTH, targetBOTH)
  
  simpleNetwork(dualComponentNetwork, fontSize = 14, nodeColour = rainbow(6),
                linkDistance = 100, zoom = TRUE)
}

micronetAndLoop()
```

### Combined MicroNetworks

Manipulating the two networks, they can easily be seen as discrete entities — however, we can also combine these two networks to form a larger, more complex network.

For instance, if we wanted to develop a network model where if A, B, and C were all true, a positive feedback loop would be the output, we can develop the micronetwork here:

```{r}

# The only change made here is adding "Da (Out)" to the end of our src list.

srcAND <- c("Aa (In)", "Ba (In)", "Ca (In)",
            "(1a)+", "(2a)+", "(3a)+",
            "(1a)+", "(2a)+", "(3a)+",
            "(4a)+", "(4a)+", "(6a)-",
            "(7a)-", "(5a)+", "Da (Out)")

# The only change made is adding "Al (In)" to the end of our target list.

targetAND <- c("(1a)+", "(2a)+", "(3a)+",
               "(4a)+", "(4a)+", "(4a)+",
               "(5a)+", "(5a)+", "(5a)+",
               "(6a)-", "(7a)-", "(5a)+",
               "(5a)+", "Da (Out)", "Al (In)")

# The following vectors of neurons were not modified at all.

srcLOOP <- c("Al (In)",
             "(1l)+", "(2l)+", "(3l)+", "(4l)+",
             "(3l)+")

targetLOOP <- c("(1l)+",
                "(2l)+", "(3l)+", "(4l)+", "(1l)+",
                "Bl (Out)")

micronetAndLoop()
```

In a case like this, it's as easy as linking the output neuron Da (Out) to the input neuron Al (In), and assembling the rest of the network using the `micronetAndLoop()` function we wrote earlier.

While this neural network appears more complicated, the function reflects exactly what structure we designed for it. In other words, if input neurons Aa (In), Ba (In), and Ca (In) all experience a stimulus, they will result in output neuron Bl (Out) releasing regular pulses due to the positive feedback loop.

We can link up MicroNetworks in many different configurations to model any variety of neuronal pathway, provided that we have a basic understanding of the structural motifs which represent these computational operators in our target organisms.

# Limitations

## Modular Simplicity

(may not account for brain complexity)

## Coloring Limitations

(same color can be confusing, label excitatory / inhibitory / input / output neurons?)

## Modular Generalizability

(not compared to microscopy yet)

## Transmission Directionality

(arrow-paths to show neural transmission)

# Future Directions

One of the primary aims of the PaperBrain / MicroNetwork project is to allow for a simple interface where researchers in Systems or Computational Neuroscience and various other fields can construct these models using language one might ordinarily see while programming. For instance, a programmer could write:

`if (A & B & C) {`
  `while (I == FALSE) {`
    `triggerOutput()`
  `}`
`}`

PapeRBrain could interpret this code as a combination of an And MicroNetwork (recognizing the `&` operator) and a Loop MicroNetwork (recognizing the `while` loop), and construct the neurobiological representation of this code using `networkd3`.

(Looking carefully at this code, the Loop MicroNetwork may be constructed as a Loop unit with some input neuron I acting as an inhibitory element on the positive feedback loop)

Constructing these complex assemblies can be modular, and MicroNetwork units such as "And," "Loop," "Not," and "Or" (among others) can be modularly assembled using the syntax of computer programming (which may be a useful construction interface for programmers).

Another goal of the PBMN project is to inspect the basic modular circuits which form the nervous systems of simpler organisms, and design a directory for MicroNetworks where the relevant units for certain species can be easily retrieved. As a sub-goal, I would like to standardize the nomenclature for neurons in MicroNetworks, to minimize confusion.

Finally, I hope to make the visualizations more functional by designing an interface where the circuit can be interacted with: various neurons can be triggered in order to assess the circuit's redundancies, areas for improvement, or simply effectiveness.
